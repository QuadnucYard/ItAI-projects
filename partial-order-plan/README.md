# 偏序规划

## 前向搜索

假定 goal 是合取式，且没有非运算。

因为初始状态是确定的，决策结果也是确定的，所以可以用集合表示为 true 的变量，凡是没在初始状态出现的变量都是 false。
扩展时，按照 precond 检查是否可行，用 effect 更新状态即可。

达成目标的条件是当前状态包含目标状态。

## 后向搜索

这里对 goal 要求较低，允许非运算。

但是状态不能直接用集合表示，因为存在不确定的变量。从目标状态出发，目标状态里有的变量值的确定的，其余变量是真是假不确定，故每个变量值是三态的：真，假，未知。
如果一个状态可能由某一决策达到，那么必须满足它的 effect，即 effect 里出现的变量值在当前状态必须出现。沿着 effect 倒推上一个状态时，要先把在 effect 中出现的变量值设为未知，然后用 precond 里确定的值更新上一个状态。

结束条件为当前状态等于初始状态。

## 优化

## 内存优化

内存优化的重点是状态的表示。在原先的算法中，使用了 `map<string, bool>`，它的 key 是复杂类型，占用内存较多。而且在状态维护中会发生多次不必要的复制，开销较大。

这里需要使用离散化，将变量名的字符串映射到数值。可以用一个 `vector` 存储所有的变量名，下标即为它的对应值。所有 `Literal` 不再存变量名，而是变量 id。这样可以用一个二元组 `(id, value)` 表示变量取值。

但是，用一个 `map` 来表示状态占用内存还是太多了。一个变量本身 8bytes（如果 `id` 是 `int8` 可以降到 2bytes），而 RBT 的一个结点就需要 24bytes 来维护树形结构，很不划算。这样就有了下面的状态表示优化。

### 状态表示优化

在前向搜索中可以用二进制状态，直接上状压就行了。因为这是一个搜索问题，变量不会很多（多了也解决不了），可以认为有一个较小的上界，`int64` 或 `int128` 即可接受。

但是后向搜索的变量是三值的，如何表示三进制状态？要解决 3 个操作：includes，contains，modify。

现成是三进制结构是没有的，但我们可以用四进制！把相邻两个二进制位合成一个四进制位。00b 表示未知，01b 表示假，10b 表示真，11b 无效。将二进制表示的 bool 值加 1 就可以得到四进制 bool 值。

#### 包含

集合的包含关系，按位运算表如下：

|     | 00b | 01b | 10b |
| :-: | :-: | :-: | :-: |
| 00b |  T  |  F  |  F  |
| 01b |  T  |  T  |  F  |
| 10b |  T  |  F  |  T  |

可以直接检查位包含，当成二进制来做。

#### 属于

forward 中的 checker：位值与要求相同。
backward 中的 checker：对三态分类讨论。

这个直接取值判断就行了。

### Preconditions/Effects 优化

发现搜索过程中还有一个需要遍历的地方，检查 preconds 和 effects 的每项。这两者本质上是对状态的约束，之前已经实现了状态压缩，能否把这个也优化掉呢？

这两者完全可以用“状态”表示。在初始化阶段，按照约束的 true/false 对其赋值，为 0 的四进制位表示没有约束。根据后续要求，还需生成它们的 mask，把不为 0 的四进制位设为 0b11。

然后解决一些问题：

1. 正向搜索的 `checker`。当前状态包含所有前提，那么直接检查 `cur_state` 是否包含 `preconds` 就行了。
2. 反向搜索的 `checker`。检查复杂一些，只关心在 `cur_state` 和 `effects` 里都不为 0 的位。用 mask 把 `cur_state` 中的无关位消除掉，再检查和 `effects` 是否有不同位，有则表明不通过。消除 `effecrs` 中的变量状态就很简单了，可以用 mask、
3. `modify_state`。因为已经变成用另一个 `quatset` 来修改状态了，所以可以改成 `quatset` 的成员函数。附加一个 `mask` 参数，用于指明哪些位需要修改。

这样成功把复杂度降低一个数量级，不再和每个 action 的附加条件数量相关。

### 最终时间复杂度分析

设 action 的数量为 $n$，存在 $m$ 个变量，那么状态数最多为 $3^m$。
每个状态只搜一遍，扩展时需要遍历 $n$ 个 action。
因此时间复杂度为 $O(n3^m)$。
