# 偏序规划

## 前向搜索

假定 goal 是合取式，且没有非运算。

因为初始状态是确定的，决策结果也是确定的，所以可以用集合表示为 true 的变量，凡是没在初始状态出现的变量都是 false。
扩展时，按照 precond 检查是否可行，用 effect 更新状态即可。

达成目标的条件是当前状态包含目标状态。

## 后向搜索

这里对 goal 要求较低，允许非运算。

但是状态不能直接用集合表示，因为存在不确定的变量。从目标状态出发，目标状态里有的变量值的确定的，其余变量是真是假不确定，故每个变量值是三态的：真，假，未知。
如果一个状态可能由某一决策达到，那么必须满足它的 effect，即 effect 里出现的变量值在当前状态必须出现。沿着 effect 倒推上一个状态时，要先把在 effect 中出现的变量值设为未知，然后用 precond 里确定的值更新上一个状态。

结束条件为当前状态等于初始状态。

### 内存优化

内存优化的重点是状态的表示。在原先的算法中，使用了 `map<string, bool>`，它的 key 是复杂类型，占用内存较多。而且在状态维护中会发生多次不必要的复制，开销较大。

这里需要使用离散化，将变量名的字符串映射到数值。可以用一个 `vector` 存储所有的变量名，下标即为它的对应值。所有 `Literal` 不再存变量名，而是变量 id。这样可以用一个二元组 `(id, value)` 表示变量取值。

但是，用一个 `map` 来表示状态占用内存还是太多了。一个变量本身 8bytes（如果 `id` 是 `int8` 可以降到 2bytes），而 RBT 的一个结点就需要 24bytes 来维护树形结构，很不划算。这样就有了下面的状态表示优化。

### 状态表示优化

在前向搜索中可以用二进制状态，直接上状压就行了。因为这是一个搜索问题，变量不会很多（多了也解决不了），可以认为有一个较小的上界，`int64` 或 `int128` 即可接受。

但是后向搜索的变量是三值的，如何表示三进制状态？要解决 3 个操作：includes，contains，modify。

现成是三进制结构是没有的，但我们可以用四进制！把相邻两个二进制位合成一个四进制位。00b 表示未知，01b 表示假，10b 表示真，11b 无效。将二进制表示的 bool 值加 1 就可以得到四进制 bool 值。

#### 包含

集合的包含关系，按位运算表如下：

|     | 00b | 01b | 10b |
| :-: | :-: | :-: | :-: |
| 00b |  T  |  F  |  F  |
| 01b |  T  |  T  |  F  |
| 10b |  T  |  F  |  T  |

可以直接检查位包含，当成二进制来做。

#### 属于

forward 中的 checker：位值与要求相同。
backward 中的 checker：对三态分类讨论。

这个直接取值判断就行了。
